diff --git a/configure.ac b/configure.ac
index 40cca58..2defbd4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -53,8 +53,8 @@ AC_PREREQ([2.57])
 #
 
 m4_define([pixman_major], 0)
-m4_define([pixman_minor], 22)
-m4_define([pixman_micro], 0)
+m4_define([pixman_minor], 23)
+m4_define([pixman_micro], 1)
 
 m4_define([pixman_version],[pixman_major.pixman_minor.pixman_micro])
 
@@ -650,6 +650,11 @@ fi
 AC_CHECK_HEADER([sys/mman.h],
    [AC_DEFINE(HAVE_SYS_MMAN_H, [1], [Define to 1 if we have <sys/mman.h>])])
 
+AC_CHECK_FUNC(mmap, have_mmap=yes, have_mmap=no)
+if test x$have_mmap = xyes; then
+   AC_DEFINE(HAVE_MMAP, 1, [Whether we have mmap()])
+fi
+
 AC_CHECK_FUNC(mprotect, have_mprotect=yes, have_mprotect=no)
 if test x$have_mprotect = xyes; then
    AC_DEFINE(HAVE_MPROTECT, 1, [Whether we have mprotect()])
diff --git a/demos/alpha-test.c b/demos/alpha-test.c
index 92c2081..54e30fa 100644
--- a/demos/alpha-test.c
+++ b/demos/alpha-test.c
@@ -40,10 +40,12 @@ main (int argc, char **argv)
     };
 #endif
 
+#if 0
     pixman_point_fixed_t c_inner;
     pixman_point_fixed_t c_outer;
     pixman_fixed_t r_inner;
     pixman_fixed_t r_outer;
+#endif
     
     for (i = 0; i < WIDTH * HEIGHT; ++i)
 	alpha[i] = 0x4f00004f; /* pale blue */
@@ -69,6 +71,7 @@ main (int argc, char **argv)
 					src,
 					WIDTH * 4);
     
+#if 0
     c_inner.x = pixman_double_to_fixed (50.0);
     c_inner.y = pixman_double_to_fixed (50.0);
     c_outer.x = pixman_double_to_fixed (50.0);
@@ -76,7 +79,6 @@ main (int argc, char **argv)
     r_inner = 0;
     r_outer = pixman_double_to_fixed (50.0);
     
-#if 0
     grad_img = pixman_image_create_conical_gradient (&c_inner, r_inner,
 						    stops, 2);
 #endif
diff --git a/demos/gradient-test.c b/demos/gradient-test.c
index fc84844..20f78a6 100644
--- a/demos/gradient-test.c
+++ b/demos/gradient-test.c
@@ -36,10 +36,12 @@ main (int argc, char **argv)
     };
 #endif
 
+#if 0
     pixman_point_fixed_t c_inner;
     pixman_point_fixed_t c_outer;
     pixman_fixed_t r_inner;
     pixman_fixed_t r_outer;
+#endif
     
     for (i = 0; i < WIDTH * HEIGHT; ++i)
 	dest[i] = 0x4f00004f; /* pale blue */
@@ -49,6 +51,7 @@ main (int argc, char **argv)
 					 dest,
 					 WIDTH * 4);
 
+#if 0
     c_inner.x = pixman_double_to_fixed (50.0);
     c_inner.y = pixman_double_to_fixed (50.0);
     c_outer.x = pixman_double_to_fixed (50.0);
@@ -58,6 +61,7 @@ main (int argc, char **argv)
     
     src_img = pixman_image_create_conical_gradient (&c_inner, r_inner,
 						    stops, 2);
+#endif
 #if 0
     src_img = pixman_image_create_conical_gradient (&c_inner, r_inner,
 						    stops, 2);
diff --git a/pixman/Makefile.am b/pixman/Makefile.am
index be08266..1e20bb0 100644
--- a/pixman/Makefile.am
+++ b/pixman/Makefile.am
@@ -20,6 +20,7 @@ libpixman_1_la_SOURCES =			\
 	pixman-combine64.h			\
 	pixman-general.c			\
 	pixman.c				\
+	pixman-noop.c				\
 	pixman-fast-path.c			\
 	pixman-fast-path.h			\
 	pixman-solid-fill.c			\
diff --git a/pixman/Makefile.win32 b/pixman/Makefile.win32
index b5f9397..7c92722 100644
--- a/pixman/Makefile.win32
+++ b/pixman/Makefile.win32
@@ -49,6 +49,7 @@ SOURCES =				\
 	pixman-radial-gradient.c	\
 	pixman-bits-image.c		\
 	pixman.c			\
+	pixman-noop.c			\
 	pixman-cpu.c			\
 	pixman-fast-path.c		\
 	pixman-implementation.c		\
diff --git a/pixman/pixman-bits-image.c b/pixman/pixman-bits-image.c
index 835ecfb..4e9ed14 100644
--- a/pixman/pixman-bits-image.c
+++ b/pixman/pixman-bits-image.c
@@ -1462,43 +1462,22 @@ dest_write_back_wide (pixman_iter_t *iter)
     iter->y++;
 }
 
-static void
-dest_write_back_direct (pixman_iter_t *iter)
-{
-    iter->buffer += iter->image->bits.rowstride;
-}
-
 void
 _pixman_bits_image_dest_iter_init (pixman_image_t *image, pixman_iter_t *iter)
 {
     if (iter->flags & ITER_NARROW)
     {
-	if (((image->common.flags &
-	      (FAST_PATH_NO_ALPHA_MAP | FAST_PATH_NO_ACCESSORS)) ==
-	     (FAST_PATH_NO_ALPHA_MAP | FAST_PATH_NO_ACCESSORS)) &&
-	    (image->bits.format == PIXMAN_a8r8g8b8	||
-	     (image->bits.format == PIXMAN_x8r8g8b8	&&
-	      (iter->flags & ITER_LOCALIZED_ALPHA))))
+	if ((iter->flags & (ITER_IGNORE_RGB | ITER_IGNORE_ALPHA)) ==
+	    (ITER_IGNORE_RGB | ITER_IGNORE_ALPHA))
 	{
-	    iter->buffer = image->bits.bits + iter->y * image->bits.rowstride + iter->x;
-
 	    iter->get_scanline = _pixman_iter_get_scanline_noop;
-	    iter->write_back = dest_write_back_direct;
 	}
 	else
 	{
-	    if ((iter->flags & (ITER_IGNORE_RGB | ITER_IGNORE_ALPHA)) ==
-		(ITER_IGNORE_RGB | ITER_IGNORE_ALPHA))
-	    {
-		iter->get_scanline = _pixman_iter_get_scanline_noop;
-	    }
-	    else
-	    {
-		iter->get_scanline = dest_get_scanline_narrow;
-	    }
-
-	    iter->write_back = dest_write_back_narrow;
+	    iter->get_scanline = dest_get_scanline_narrow;
 	}
+	
+	iter->write_back = dest_write_back_narrow;
     }
     else
     {
diff --git a/pixman/pixman-combine.c.template b/pixman/pixman-combine.c.template
index f5dd8e1..806a184 100644
--- a/pixman/pixman-combine.c.template
+++ b/pixman/pixman-combine.c.template
@@ -437,7 +437,7 @@ combine_saturate_u (pixman_implementation_t *imp,
  * PDF_NON_SEPARABLE_BLEND_MODE macros, which take the blend function as an
  * argument. Note that this implementation operates on premultiplied colors,
  * while the PDF specification does not. Therefore the code uses the formula
- * ar.Cra = (1 – as) . Dca + (1 – ad) . Sca + B(Dca, ad, Sca, as)
+ * Cra = (1 – as) . Dca + (1 – ad) . Sca + B(Dca, ad, Sca, as)
  */
 
 /*
@@ -849,7 +849,7 @@ PDF_SEPARABLE_BLEND_MODE (exclusion)
  *
  *    r * set_sat (C, s) = set_sat (x * C, r * s)
  *
- * The above holds for all non-zero x, because they x'es in the fraction for
+ * The above holds for all non-zero x, because the x'es in the fraction for
  * C_mid cancel out. Specifically, it holds for x = r:
  *
  *    r * set_sat (C, s) = set_sat (r_c, rs)
@@ -885,8 +885,7 @@ PDF_SEPARABLE_BLEND_MODE (exclusion)
  *
  *     a_s * a_d * B(s, d)
  *   = a_s * a_d * set_lum (set_sat (S/a_s, SAT (D/a_d)), LUM (D/a_d), 1)
- *   = a_s * a_d * set_lum (set_sat (a_d * S, a_s * SAT (D)),
- *                                        a_s * LUM (D), a_s * a_d)
+ *   = set_lum (set_sat (a_d * S, a_s * SAT (D)), a_s * LUM (D), a_s * a_d)
  *
  */
 
diff --git a/pixman/pixman-cpu.c b/pixman/pixman-cpu.c
index 0e14ecb..973ed54 100644
--- a/pixman/pixman-cpu.c
+++ b/pixman/pixman-cpu.c
@@ -606,6 +606,8 @@ _pixman_choose_implementation (void)
 	imp = _pixman_implementation_create_vmx (imp);
 #endif
 
+    imp = _pixman_implementation_create_noop (imp);
+    
     return imp;
 }
 
diff --git a/pixman/pixman-implementation.c b/pixman/pixman-implementation.c
index f1d3f99..81c740b 100644
--- a/pixman/pixman-implementation.c
+++ b/pixman/pixman-implementation.c
@@ -241,12 +241,6 @@ _pixman_implementation_fill (pixman_implementation_t *imp,
     return (*imp->fill) (imp, bits, stride, bpp, x, y, width, height, xor);
 }
 
-static uint32_t *
-get_scanline_null (pixman_iter_t *iter, const uint32_t *mask)
-{
-    return NULL;
-}
-
 void
 _pixman_implementation_src_iter_init (pixman_implementation_t	*imp,
 				      pixman_iter_t             *iter,
@@ -266,19 +260,7 @@ _pixman_implementation_src_iter_init (pixman_implementation_t	*imp,
     iter->height = height;
     iter->flags = flags;
 
-    if (!image)
-    {
-	iter->get_scanline = get_scanline_null;
-    }
-    else if ((flags & (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB)) ==
-	     (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB))
-    {
-	iter->get_scanline = _pixman_iter_get_scanline_noop;
-    }
-    else
-    {
-	(*imp->src_iter_init) (imp, iter);
-    }
+    (*imp->src_iter_init) (imp, iter);
 }
 
 void
diff --git a/pixman/pixman-mmx.c b/pixman/pixman-mmx.c
index 0272347..62a73d6 100644
--- a/pixman/pixman-mmx.c
+++ b/pixman/pixman-mmx.c
@@ -1267,7 +1267,7 @@ mmx_composite_over_n_8888_8888_ca (pixman_implementation_t *imp,
                                    int32_t                  width,
                                    int32_t                  height)
 {
-    uint32_t src, srca;
+    uint32_t src;
     uint32_t    *dst_line;
     uint32_t    *mask_line;
     int dst_stride, mask_stride;
@@ -1277,7 +1277,6 @@ mmx_composite_over_n_8888_8888_ca (pixman_implementation_t *imp,
 
     src = _pixman_image_get_solid (imp, src_image, dst_image->bits.format);
 
-    srca = src >> 24;
     if (src == 0)
 	return;
 
@@ -1377,7 +1376,6 @@ mmx_composite_over_8888_n_8888 (pixman_implementation_t *imp,
     __m64 vmask;
     int dst_stride, src_stride;
     int32_t w;
-    __m64 srca;
 
     CHECKPOINT ();
 
@@ -1388,7 +1386,6 @@ mmx_composite_over_8888_n_8888 (pixman_implementation_t *imp,
     mask &= 0xff000000;
     mask = mask | mask >> 8 | mask >> 16 | mask >> 24;
     vmask = load8888 (mask);
-    srca = MC (4x00ff);
 
     while (height--)
     {
@@ -2033,7 +2030,7 @@ mmx_composite_src_n_8_8888 (pixman_implementation_t *imp,
     uint8_t     *mask_line, *mask;
     int dst_stride, mask_stride;
     int32_t w;
-    __m64 vsrc, vsrca;
+    __m64 vsrc;
     uint64_t srcsrc;
 
     CHECKPOINT ();
@@ -2055,7 +2052,6 @@ mmx_composite_src_n_8_8888 (pixman_implementation_t *imp,
     PIXMAN_IMAGE_GET_LINE (mask_image, mask_x, mask_y, uint8_t, mask_stride, mask_line, 1);
 
     vsrc = load8888 (src);
-    vsrca = expand_alpha (vsrc);
 
     while (height--)
     {
@@ -2101,11 +2097,8 @@ mmx_composite_src_n_8_8888 (pixman_implementation_t *imp,
 	    }
 	    else if (m0 | m1)
 	    {
-		__m64 vdest;
 		__m64 dest0, dest1;
 
-		vdest = *(__m64 *)dst;
-
 		dest0 = in (vsrc, expand_alpha_rev (to_m64 (m0)));
 		dest1 = in (vsrc, expand_alpha_rev (to_m64 (m1)));
 
@@ -2524,7 +2517,7 @@ mmx_composite_over_n_8888_0565_ca (pixman_implementation_t *imp,
                                    int32_t                  width,
                                    int32_t                  height)
 {
-    uint32_t src, srca;
+    uint32_t src;
     uint16_t    *dst_line;
     uint32_t    *mask_line;
     int dst_stride, mask_stride;
@@ -2534,7 +2527,6 @@ mmx_composite_over_n_8888_0565_ca (pixman_implementation_t *imp,
 
     src = _pixman_image_get_solid (imp, src_image, dst_image->bits.format);
 
-    srca = src >> 24;
     if (src == 0)
 	return;
 
@@ -2663,12 +2655,9 @@ mmx_composite_in_n_8_8 (pixman_implementation_t *imp,
 	{
 	    while (w >= 4)
 	    {
-		uint32_t m;
 		__m64 vmask;
 		__m64 vdest;
 
-		m = 0;
-
 		vmask = load8888 (*(uint32_t *)mask);
 		vdest = load8888 (*(uint32_t *)dst);
 
diff --git a/pixman/pixman-noop.c b/pixman/pixman-noop.c
new file mode 100644
index 0000000..cc8dbc9
--- /dev/null
+++ b/pixman/pixman-noop.c
@@ -0,0 +1,148 @@
+/* -*- Mode: c; c-basic-offset: 4; tab-width: 8; indent-tabs-mode: t; -*- */
+/*
+ * Copyright © 2011 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <string.h>
+#include <stdlib.h>
+#include "pixman-private.h"
+#include "pixman-combine32.h"
+#include "pixman-fast-path.h"
+
+static void
+noop_composite (pixman_implementation_t *imp,
+		pixman_op_t              op,
+		pixman_image_t *         src,
+		pixman_image_t *         mask,
+		pixman_image_t *         dest,
+		int32_t                  src_x,
+		int32_t                  src_y,
+		int32_t                  mask_x,
+		int32_t                  mask_y,
+		int32_t                  dest_x,
+		int32_t                  dest_y,
+		int32_t                  width,
+		int32_t                  height)
+{
+    return;
+}
+
+static void
+dest_write_back_direct (pixman_iter_t *iter)
+{
+    iter->buffer += iter->image->bits.rowstride;
+}
+
+static uint32_t *
+noop_get_scanline (pixman_iter_t *iter, const uint32_t *mask)
+{
+    uint32_t *result = iter->buffer;
+
+    iter->buffer += iter->image->bits.rowstride;
+
+    return result;
+}
+
+static uint32_t *
+get_scanline_null (pixman_iter_t *iter, const uint32_t *mask)
+{
+    return NULL;
+}
+
+static void
+noop_src_iter_init (pixman_implementation_t *imp, pixman_iter_t *iter)
+{
+    pixman_image_t *image = iter->image;
+
+#define FLAGS						\
+    (FAST_PATH_STANDARD_FLAGS | FAST_PATH_ID_TRANSFORM)
+
+    if (!image)
+    {
+	iter->get_scanline = get_scanline_null;
+    }
+    else if ((iter->flags & (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB)) ==
+	     (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB))
+    {
+	iter->get_scanline = _pixman_iter_get_scanline_noop;
+    }
+    else if ((iter->flags & ITER_NARROW)				&&
+	     (image->common.flags & FLAGS) == FLAGS			&&
+	     iter->x >= 0 && iter->y >= 0				&&
+	     iter->x + iter->width <= image->bits.width			&&
+	     iter->y + iter->height <= image->bits.height		&&
+	     image->common.extended_format_code == PIXMAN_a8r8g8b8)
+    {
+	iter->buffer =
+	    image->bits.bits + iter->y * image->bits.rowstride + iter->x;
+
+	iter->get_scanline = noop_get_scanline;
+    }
+    else
+    {
+	(* imp->delegate->src_iter_init) (imp->delegate, iter);
+    }
+}
+
+static void
+noop_dest_iter_init (pixman_implementation_t *imp, pixman_iter_t *iter)
+{
+    pixman_image_t *image = iter->image;
+    uint32_t image_flags = image->common.flags;
+    uint32_t iter_flags = iter->flags;
+
+    if ((image_flags & FAST_PATH_STD_DEST_FLAGS) == FAST_PATH_STD_DEST_FLAGS	&&
+	(iter_flags & ITER_NARROW) == ITER_NARROW				&&
+	((image->common.extended_format_code == PIXMAN_a8r8g8b8)	||
+	 (image->common.extended_format_code == PIXMAN_x8r8g8b8 &&
+	  (iter_flags & (ITER_LOCALIZED_ALPHA)))))
+    {
+	iter->buffer = image->bits.bits + iter->y * image->bits.rowstride + iter->x;
+
+	iter->get_scanline = _pixman_iter_get_scanline_noop;
+	iter->write_back = dest_write_back_direct;
+    }
+    else
+    {
+	(* imp->delegate->dest_iter_init) (imp->delegate, iter);
+    }
+}
+
+static const pixman_fast_path_t noop_fast_paths[] =
+{
+    { PIXMAN_OP_DST, PIXMAN_any, 0, PIXMAN_any, 0, PIXMAN_any, 0, noop_composite },
+    { PIXMAN_OP_NONE },
+};
+
+pixman_implementation_t *
+_pixman_implementation_create_noop (pixman_implementation_t *fallback)
+{
+    pixman_implementation_t *imp =
+	_pixman_implementation_create (fallback, noop_fast_paths);
+
+    imp->src_iter_init = noop_src_iter_init;
+    imp->dest_iter_init = noop_dest_iter_init;
+
+    return imp;
+}
diff --git a/pixman/pixman-private.h b/pixman/pixman-private.h
index 60060a9..2996907 100644
--- a/pixman/pixman-private.h
+++ b/pixman/pixman-private.h
@@ -523,6 +523,9 @@ _pixman_implementation_create_general (void);
 pixman_implementation_t *
 _pixman_implementation_create_fast_path (pixman_implementation_t *fallback);
 
+pixman_implementation_t *
+_pixman_implementation_create_noop (pixman_implementation_t *fallback);
+
 #ifdef USE_MMX
 pixman_implementation_t *
 _pixman_implementation_create_mmx (pixman_implementation_t *fallback);
diff --git a/pixman/pixman-sse2.c b/pixman/pixman-sse2.c
index 533b858..1fd66bf 100644
--- a/pixman/pixman-sse2.c
+++ b/pixman/pixman-sse2.c
@@ -2537,20 +2537,19 @@ sse2_composite_add_n_8888_8888_ca (pixman_implementation_t *imp,
 				   int32_t                  width,
 				   int32_t                  height)
 {
-    uint32_t src, srca;
+    uint32_t src;
     uint32_t    *dst_line, d;
     uint32_t    *mask_line, m;
     uint32_t pack_cmp;
     int dst_stride, mask_stride;
 
-    __m128i xmm_src, xmm_alpha;
+    __m128i xmm_src;
     __m128i xmm_dst;
     __m128i xmm_mask, xmm_mask_lo, xmm_mask_hi;
 
-    __m128i mmx_src, mmx_alpha, mmx_mask, mmx_dest;
+    __m128i mmx_src, mmx_mask, mmx_dest;
 
     src = _pixman_image_get_solid (imp, src_image, dst_image->bits.format);
-    srca = src >> 24;
 
     if (src == 0)
 	return;
@@ -2562,9 +2561,7 @@ sse2_composite_add_n_8888_8888_ca (pixman_implementation_t *imp,
 
     xmm_src = _mm_unpacklo_epi8 (
 	create_mask_2x32_128 (src, src), _mm_setzero_si128 ());
-    xmm_alpha = expand_alpha_1x128 (xmm_src);
     mmx_src   = xmm_src;
-    mmx_alpha = xmm_alpha;
 
     while (height--)
     {
@@ -3628,7 +3625,7 @@ sse2_composite_over_n_8_0565 (pixman_implementation_t *imp,
                               int32_t                  width,
                               int32_t                  height)
 {
-    uint32_t src, srca;
+    uint32_t src;
     uint16_t    *dst_line, *dst, d;
     uint8_t     *mask_line, *mask;
     int dst_stride, mask_stride;
@@ -3642,7 +3639,6 @@ sse2_composite_over_n_8_0565 (pixman_implementation_t *imp,
 
     src = _pixman_image_get_solid (imp, src_image, dst_image->bits.format);
 
-    srca = src >> 24;
     if (src == 0)
 	return;
 
@@ -4143,7 +4139,6 @@ sse2_composite_in_n_8_8 (pixman_implementation_t *imp,
     int dst_stride, mask_stride;
     uint32_t d, m;
     uint32_t src;
-    uint8_t sa;
     int32_t w;
 
     __m128i xmm_alpha;
@@ -4157,8 +4152,6 @@ sse2_composite_in_n_8_8 (pixman_implementation_t *imp,
 
     src = _pixman_image_get_solid (imp, src_image, dst_image->bits.format);
 
-    sa = src >> 24;
-
     xmm_alpha = expand_alpha_1x128 (expand_pixel_32_1x128 (src));
 
     while (height--)
@@ -4415,7 +4408,6 @@ sse2_composite_add_n_8_8 (pixman_implementation_t *imp,
     int dst_stride, mask_stride;
     int32_t w;
     uint32_t src;
-    uint8_t sa;
     uint32_t m, d;
 
     __m128i xmm_alpha;
@@ -4429,8 +4421,6 @@ sse2_composite_add_n_8_8 (pixman_implementation_t *imp,
 
     src = _pixman_image_get_solid (imp, src_image, dst_image->bits.format);
 
-    sa = src >> 24;
-
     xmm_alpha = expand_alpha_1x128 (expand_pixel_32_1x128 (src));
 
     while (height--)
diff --git a/pixman/pixman.c b/pixman/pixman.c
index f21af2f..61d3a92 100644
--- a/pixman/pixman.c
+++ b/pixman/pixman.c
@@ -761,8 +761,6 @@ pixman_image_composite32 (pixman_op_t      op,
      * mathematically equivalent to the source.
      */
     op = optimize_operator (op, src_flags, mask_flags, dest_flags);
-    if (op == PIXMAN_OP_DST)
-	goto out;
 
     if (lookup_composite_function (op,
 				   src_format, src_flags,
diff --git a/test/composite.c b/test/composite.c
index 9a001e5..edea9a9 100644
--- a/test/composite.c
+++ b/test/composite.c
@@ -877,7 +877,7 @@ main (int argc, char **argv)
 {
 #define N_TESTS (8 * 1024 * 1024)
     int result = 0;
-    uint32_t i;
+    uint32_t i, seed;
 
     if (argc > 1)
     {
@@ -899,8 +899,6 @@ main (int argc, char **argv)
 	}
     }
 
-    uint32_t seed;
-    
     if (getenv ("PIXMAN_RANDOMIZE_TESTS"))
 	seed = get_random_seed();
     else
diff --git a/test/utils.c b/test/utils.c
index 56701c4..4025602 100644
--- a/test/utils.c
+++ b/test/utils.c
@@ -229,7 +229,7 @@ typedef struct
     int n_bytes;
 } info_t;
 
-#if defined(HAVE_MPROTECT) && defined(HAVE_GETPAGESIZE) && defined(HAVE_SYS_MMAN_H)
+#if defined(HAVE_MPROTECT) && defined(HAVE_GETPAGESIZE) && defined(HAVE_SYS_MMAN_H) && defined(HAVE_MMAP)
 
 /* This is apparently necessary on at least OS X */
 #ifndef MAP_ANONYMOUS
